<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Reactor Designer (webgl)</title>
<!--
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.11.4/themes/ui-darkness/jquery-ui.css">
        <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
        <script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
-->
        <link href="css/reactor.css" rel="stylesheet">
        <script src="js/structures.js"></script>
        <script src="js/ui.js"></script>

        <script src="js/my_webgl.js"></script>
        <script>
            "use strict";

            window.onload = function() {

                var kernel = [
                    0.01, 0.01, 0.01, 0.01, 0.01,
                    0.01, 0.08, 0.08, 0.08, 0.01,
                    0.01, 0.08, 0.2, 0.08, 0.01,
                    0.01, 0.08, 0.08, 0.08, 0.01,
                    0.01, 0.01, 0.01, 0.01, 0.01,
                ];

                var fields = new Float32Array(550*1100*4);

                for(var i = 0; i < 550*1100*4; i++){

                    if (i % 4 === 3) {
                        fields[i] = 1.0;
                    }else if (i % 4 === 0) {
                        fields[i] = Math.random();
                    }
                }

                var kernel_size = 11*11*25*2*4;

                var kernels = new Float32Array(kernel_size);

                for(var j = 0; j < 11*11*25*2; j++) {
                    kernels[j*4] = kernel[j % 25];
                }

                // Get A WebGL context

                var my = WebGL.make("canvas");


                var program = my.linkProgram({
                    vertexShaderSource : document.getElementById("cellblock_step_vert").text,
                    fragmentShaderSource : document.getElementById("cellblock_step_frag").text
                });

                my.enableFloatTexture();


                // set the resolution
                program.addUniformFloat("u_resolution", [my.canvas.width, my.canvas.height]);

                program.addUniformFloat("u_numCells", 50);

                program.addUniformFloat("u_numBlocks", [11, 11]);

                program.addUniformFloat("u_numFields", 2);



                // fields
                var initfields = my.addTextureArray(1100, 550, fields, true).bindToTextureUnit(program, "u_fields", "u_fieldTexSize");

                var fbA = my.addFrameBuffer(1100, 550, true);
                var fbB = my.addFrameBuffer(1100, 550, true);

                my.addTextureArray(11*5*2, 11*5, kernels, true).bindToTextureUnit(program, "u_kernels", "u_kernelTexSize");

                // interactions between fields
                my.addTextureArray(2, 2, new Float32Array([
                    0.0, 0.0, 0.0, 0.0,
                    0.0, 0.0, 0.0, 0.0,
                    0.0, 0.0, 0.0, 0.0,
                    0.0, 0.0, 0.0, 0.0,
                ]), true).bindToTextureUnit(program, "u_interactions", "u_interactionTexSize");

                // triangle vertices
                my.addArrayFloat([
                    [0, 0],
                    [my.canvas.width, 0],
                    [0, my.canvas.height],
                    [0, my.canvas.height],
                    [my.canvas.width, 0],
                    [my.canvas.width, my.canvas.height]
                ]).bindToAttribute(program, "a_position");

                // texture coordinets for vertices
                my.addArrayFloat([
                    [0.0,  0.0],
                    [1.0,  0.0],
                    [0.0,  1.0],
                    [0.0,  1.0],
                    [1.0,  0.0],
                    [1.0,  1.0]
                ]).bindToAttribute(program, "a_texCoord");

                for(var k = 0; k < 10; k++) {
                    fbA.bind(program);

                    program.drawTriangles(0, 6);

                    fbA.texture.bindToTextureUnit(program, "u_fields", "u_fieldTexSize");

                    fbB.bind(program);

                    program.drawTriangles(0, 6);

                    fbB.texture.bindToTextureUnit(program, "u_fields", "u_fieldTexSize");
                }

                my.bindCanvas(program);

                program.drawTriangles(0, 6);

            };
        </script>


        <script id="cellblock_step_vert" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec2 a_texCoord;

        uniform vec2 u_resolution;

        varying vec2 v_texCoord;

        void main() {
           // convert the rectangle from pixels to 0.0 to 1.0
           vec2 zeroToOne = a_position / u_resolution;

           // convert from 0->1 to 0->2
           vec2 zeroToTwo = zeroToOne * 2.0;

           // convert from 0->2 to -1->+1 (clipspace)
           vec2 clipSpace = zeroToTwo - 1.0;

           gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

           v_texCoord = a_texCoord;
        }

        </script>

        <script id="cellblock_step_frag" type="x-shader/x-fragment">
            precision mediump float;

            //cellblock information
            uniform float u_numCells;
            uniform vec2 u_numBlocks;
            uniform float u_numFields;

            // fields
            uniform vec2 u_fieldTexSize;
            uniform sampler2D u_fields;

            // kernels
            uniform vec2 u_kernelTexSize;
            uniform sampler2D u_kernels;

            // field interactions
            uniform vec2 u_interactionTexSize;
            uniform sampler2D u_interactions;

            // the texCoords passed in from the vertex shader.
            varying vec2 v_texCoord;

            void main() {

                vec2 curBlock = floor(1.0001*v_texCoord * u_fieldTexSize / u_numCells);


                // modulus hackery due to rounding errors
                vec2 curFieldBlock = floor(curBlock - u_numBlocks*floor(1.0001*curBlock/u_numBlocks));


                if (curFieldBlock.x == 0.0 || curFieldBlock.x == (u_numBlocks.x-1.0) || curFieldBlock.y == 0.0 || curFieldBlock.y == (u_numBlocks.y-1.0)) {
                    // boundary does not evolove
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);

                }else{

                    // compute 1 pixel in texture coordinates.
                    vec2 dX = vec2(1.0, 0.0) / u_fieldTexSize;
                    vec2 dY = vec2(0.0, 1.0) / u_fieldTexSize;

                    vec2 dX2 = 2.0*dX;
                    vec2 dY2 = 2.0*dY;

                    // 5x5 convolution
                    vec2 kernelCenter = (curBlock * 5.0 + vec2(2.0, 2.0)) / u_kernelTexSize;
                    vec2 kdX = vec2(1.0, 0.0) / u_kernelTexSize;
                    vec2 kdY = vec2(0.0, 1.0) / u_kernelTexSize;

                    vec2 kdX2 = 2.0*kdX;
                    vec2 kdY2 = 2.0*kdY;

                    gl_FragColor =
                        texture2D(u_kernels, kernelCenter - kdX2 - kdY2) * texture2D(u_fields, v_texCoord - dX2 - dY2) + // -2
                        texture2D(u_kernels, kernelCenter - kdX - kdY2) * texture2D(u_fields, v_texCoord - dX - dY2) +
                        texture2D(u_kernels, kernelCenter - kdY2) * texture2D(u_fields, v_texCoord - dY2) +
                        texture2D(u_kernels, kernelCenter + kdX - kdY2) * texture2D(u_fields, v_texCoord + dX - dY2) +
                        texture2D(u_kernels, kernelCenter + kdX2 - kdY2) * texture2D(u_fields, v_texCoord + dX2 - dY2) +
                        texture2D(u_kernels, kernelCenter - kdX2 - kdY) * texture2D(u_fields, v_texCoord - dX2 - dY) + // -1
                        texture2D(u_kernels, kernelCenter - kdX - kdY) * texture2D(u_fields, v_texCoord - dX - dY) +
                        texture2D(u_kernels, kernelCenter - kdY) * texture2D(u_fields, v_texCoord - dY) +
                        texture2D(u_kernels, kernelCenter + kdX - kdY) * texture2D(u_fields, v_texCoord + dX - dY) +
                        texture2D(u_kernels, kernelCenter + kdX2 - kdY) * texture2D(u_fields, v_texCoord + dX2 - dY) +
                        texture2D(u_kernels, kernelCenter - kdX2) * texture2D(u_fields, v_texCoord - dX2) + // 0
                        texture2D(u_kernels, kernelCenter - kdX) * texture2D(u_fields, v_texCoord - dX) +
                        texture2D(u_kernels, kernelCenter) * texture2D(u_fields, v_texCoord) +
                        texture2D(u_kernels, kernelCenter + kdX) * texture2D(u_fields, v_texCoord + dX) +
                        texture2D(u_kernels, kernelCenter + kdX2) * texture2D(u_fields, v_texCoord + dX2) +
                        texture2D(u_kernels, kernelCenter - kdX2 + kdY) * texture2D(u_fields, v_texCoord - dX2 + dY) + // +1
                        texture2D(u_kernels, kernelCenter - kdX + kdY) * texture2D(u_fields, v_texCoord - dX + dY) +
                        texture2D(u_kernels, kernelCenter + kdY) * texture2D(u_fields, v_texCoord + dY) +
                        texture2D(u_kernels, kernelCenter + kdX + kdY) * texture2D(u_fields, v_texCoord + dX + dY) +
                        texture2D(u_kernels, kernelCenter + kdX2 + kdY) * texture2D(u_fields, v_texCoord + dX2 + dY) +
                        texture2D(u_kernels, kernelCenter - kdX2 + kdY2) * texture2D(u_fields, v_texCoord - dX2 + dY2) + // +2
                        texture2D(u_kernels, kernelCenter - kdX + kdY2) * texture2D(u_fields, v_texCoord - dX + dY2) +
                        texture2D(u_kernels, kernelCenter + kdY2) * texture2D(u_fields, v_texCoord + dY2) +
                        texture2D(u_kernels, kernelCenter + kdX + kdY2) * texture2D(u_fields, v_texCoord + dX + dY2) +
                        texture2D(u_kernels, kernelCenter + kdX2 + kdY2) * texture2D(u_fields, v_texCoord + dX2 + dY2);


                    float curField = floor(1.0001 * curBlock.x / u_numBlocks.x);

                    // interactions between fields (max of 10 fields)
                    for(float i = 0.0; i < 10.0; ++i) {
                        // this is seriously hackery
                        if (i >= u_numFields) {
                            break;
                        }

                        // self interaction is handled by kernel convolution
                        if (i != curField) {
                            gl_FragColor += texture2D(u_interactions, vec2(curField, i)/u_numFields) * texture2D(u_fields, v_texCoord);
                        }
                    }
                }
            }

        </script>

    </head>
    <body>
        <canvas id="canvas" width="1100" height="550"></canvas>

    </body>
</html>
